// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	types "k8s.io/apimachinery/pkg/types"

	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	v1alpha1 "github.com/lyft/flytepropeller/pkg/apis/flyteworkflow/v1alpha1"
)

// ExecutableWorkflow is an autogenerated mock type for the ExecutableWorkflow type
type ExecutableWorkflow struct {
	mock.Mock
}

type ExecutableWorkflow_FindSubWorkflow struct {
	*mock.Call
}

func (_m ExecutableWorkflow_FindSubWorkflow) Return(_a0 v1alpha1.ExecutableSubWorkflow) *ExecutableWorkflow_FindSubWorkflow {
	return &ExecutableWorkflow_FindSubWorkflow{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnFindSubWorkflow(subID string) *ExecutableWorkflow_FindSubWorkflow {
	c := _m.On("FindSubWorkflow", subID)
	return &ExecutableWorkflow_FindSubWorkflow{Call: c}
}

func (_m *ExecutableWorkflow) OnFindSubWorkflowMatch(matchers ...interface{}) *ExecutableWorkflow_FindSubWorkflow {
	c := _m.On("FindSubWorkflow", matchers...)
	return &ExecutableWorkflow_FindSubWorkflow{Call: c}
}

// FindSubWorkflow provides a mock function with given fields: subID
func (_m *ExecutableWorkflow) FindSubWorkflow(subID string) v1alpha1.ExecutableSubWorkflow {
	ret := _m.Called(subID)

	var r0 v1alpha1.ExecutableSubWorkflow
	if rf, ok := ret.Get(0).(func(string) v1alpha1.ExecutableSubWorkflow); ok {
		r0 = rf(subID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableSubWorkflow)
		}
	}

	return r0
}

type ExecutableWorkflow_FromNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_FromNode) Return(_a0 []string, _a1 error) *ExecutableWorkflow_FromNode {
	return &ExecutableWorkflow_FromNode{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ExecutableWorkflow) OnFromNode(name string) *ExecutableWorkflow_FromNode {
	c := _m.On("FromNode", name)
	return &ExecutableWorkflow_FromNode{Call: c}
}

func (_m *ExecutableWorkflow) OnFromNodeMatch(matchers ...interface{}) *ExecutableWorkflow_FromNode {
	c := _m.On("FromNode", matchers...)
	return &ExecutableWorkflow_FromNode{Call: c}
}

// FromNode provides a mock function with given fields: name
func (_m *ExecutableWorkflow) FromNode(name string) ([]string, error) {
	ret := _m.Called(name)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ExecutableWorkflow_GetAnnotations struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetAnnotations) Return(_a0 map[string]string) *ExecutableWorkflow_GetAnnotations {
	return &ExecutableWorkflow_GetAnnotations{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetAnnotations() *ExecutableWorkflow_GetAnnotations {
	c := _m.On("GetAnnotations")
	return &ExecutableWorkflow_GetAnnotations{Call: c}
}

func (_m *ExecutableWorkflow) OnGetAnnotationsMatch(matchers ...interface{}) *ExecutableWorkflow_GetAnnotations {
	c := _m.On("GetAnnotations", matchers...)
	return &ExecutableWorkflow_GetAnnotations{Call: c}
}

// GetAnnotations provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetAnnotations() map[string]string {
	ret := _m.Called()

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func() map[string]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	return r0
}

type ExecutableWorkflow_GetConnections struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetConnections) Return(_a0 *v1alpha1.Connections) *ExecutableWorkflow_GetConnections {
	return &ExecutableWorkflow_GetConnections{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetConnections() *ExecutableWorkflow_GetConnections {
	c := _m.On("GetConnections")
	return &ExecutableWorkflow_GetConnections{Call: c}
}

func (_m *ExecutableWorkflow) OnGetConnectionsMatch(matchers ...interface{}) *ExecutableWorkflow_GetConnections {
	c := _m.On("GetConnections", matchers...)
	return &ExecutableWorkflow_GetConnections{Call: c}
}

// GetConnections provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetConnections() *v1alpha1.Connections {
	ret := _m.Called()

	var r0 *v1alpha1.Connections
	if rf, ok := ret.Get(0).(func() *v1alpha1.Connections); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Connections)
		}
	}

	return r0
}

type ExecutableWorkflow_GetCreationTimestamp struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetCreationTimestamp) Return(_a0 v1.Time) *ExecutableWorkflow_GetCreationTimestamp {
	return &ExecutableWorkflow_GetCreationTimestamp{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetCreationTimestamp() *ExecutableWorkflow_GetCreationTimestamp {
	c := _m.On("GetCreationTimestamp")
	return &ExecutableWorkflow_GetCreationTimestamp{Call: c}
}

func (_m *ExecutableWorkflow) OnGetCreationTimestampMatch(matchers ...interface{}) *ExecutableWorkflow_GetCreationTimestamp {
	c := _m.On("GetCreationTimestamp", matchers...)
	return &ExecutableWorkflow_GetCreationTimestamp{Call: c}
}

// GetCreationTimestamp provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetCreationTimestamp() v1.Time {
	ret := _m.Called()

	var r0 v1.Time
	if rf, ok := ret.Get(0).(func() v1.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1.Time)
	}

	return r0
}

type ExecutableWorkflow_GetExecutionID struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetExecutionID) Return(_a0 v1alpha1.WorkflowExecutionIdentifier) *ExecutableWorkflow_GetExecutionID {
	return &ExecutableWorkflow_GetExecutionID{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetExecutionID() *ExecutableWorkflow_GetExecutionID {
	c := _m.On("GetExecutionID")
	return &ExecutableWorkflow_GetExecutionID{Call: c}
}

func (_m *ExecutableWorkflow) OnGetExecutionIDMatch(matchers ...interface{}) *ExecutableWorkflow_GetExecutionID {
	c := _m.On("GetExecutionID", matchers...)
	return &ExecutableWorkflow_GetExecutionID{Call: c}
}

// GetExecutionID provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetExecutionID() v1alpha1.WorkflowExecutionIdentifier {
	ret := _m.Called()

	var r0 v1alpha1.WorkflowExecutionIdentifier
	if rf, ok := ret.Get(0).(func() v1alpha1.WorkflowExecutionIdentifier); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.WorkflowExecutionIdentifier)
	}

	return r0
}

type ExecutableWorkflow_GetExecutionStatus struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetExecutionStatus) Return(_a0 v1alpha1.ExecutableWorkflowStatus) *ExecutableWorkflow_GetExecutionStatus {
	return &ExecutableWorkflow_GetExecutionStatus{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetExecutionStatus() *ExecutableWorkflow_GetExecutionStatus {
	c := _m.On("GetExecutionStatus")
	return &ExecutableWorkflow_GetExecutionStatus{Call: c}
}

func (_m *ExecutableWorkflow) OnGetExecutionStatusMatch(matchers ...interface{}) *ExecutableWorkflow_GetExecutionStatus {
	c := _m.On("GetExecutionStatus", matchers...)
	return &ExecutableWorkflow_GetExecutionStatus{Call: c}
}

// GetExecutionStatus provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetExecutionStatus() v1alpha1.ExecutableWorkflowStatus {
	ret := _m.Called()

	var r0 v1alpha1.ExecutableWorkflowStatus
	if rf, ok := ret.Get(0).(func() v1alpha1.ExecutableWorkflowStatus); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableWorkflowStatus)
		}
	}

	return r0
}

type ExecutableWorkflow_GetID struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetID) Return(_a0 string) *ExecutableWorkflow_GetID {
	return &ExecutableWorkflow_GetID{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetID() *ExecutableWorkflow_GetID {
	c := _m.On("GetID")
	return &ExecutableWorkflow_GetID{Call: c}
}

func (_m *ExecutableWorkflow) OnGetIDMatch(matchers ...interface{}) *ExecutableWorkflow_GetID {
	c := _m.On("GetID", matchers...)
	return &ExecutableWorkflow_GetID{Call: c}
}

// GetID provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetK8sWorkflowID struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetK8sWorkflowID) Return(_a0 types.NamespacedName) *ExecutableWorkflow_GetK8sWorkflowID {
	return &ExecutableWorkflow_GetK8sWorkflowID{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetK8sWorkflowID() *ExecutableWorkflow_GetK8sWorkflowID {
	c := _m.On("GetK8sWorkflowID")
	return &ExecutableWorkflow_GetK8sWorkflowID{Call: c}
}

func (_m *ExecutableWorkflow) OnGetK8sWorkflowIDMatch(matchers ...interface{}) *ExecutableWorkflow_GetK8sWorkflowID {
	c := _m.On("GetK8sWorkflowID", matchers...)
	return &ExecutableWorkflow_GetK8sWorkflowID{Call: c}
}

// GetK8sWorkflowID provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetK8sWorkflowID() types.NamespacedName {
	ret := _m.Called()

	var r0 types.NamespacedName
	if rf, ok := ret.Get(0).(func() types.NamespacedName); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(types.NamespacedName)
	}

	return r0
}

type ExecutableWorkflow_GetLabels struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetLabels) Return(_a0 map[string]string) *ExecutableWorkflow_GetLabels {
	return &ExecutableWorkflow_GetLabels{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetLabels() *ExecutableWorkflow_GetLabels {
	c := _m.On("GetLabels")
	return &ExecutableWorkflow_GetLabels{Call: c}
}

func (_m *ExecutableWorkflow) OnGetLabelsMatch(matchers ...interface{}) *ExecutableWorkflow_GetLabels {
	c := _m.On("GetLabels", matchers...)
	return &ExecutableWorkflow_GetLabels{Call: c}
}

// GetLabels provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetLabels() map[string]string {
	ret := _m.Called()

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func() map[string]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	return r0
}

type ExecutableWorkflow_GetName struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetName) Return(_a0 string) *ExecutableWorkflow_GetName {
	return &ExecutableWorkflow_GetName{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetName() *ExecutableWorkflow_GetName {
	c := _m.On("GetName")
	return &ExecutableWorkflow_GetName{Call: c}
}

func (_m *ExecutableWorkflow) OnGetNameMatch(matchers ...interface{}) *ExecutableWorkflow_GetName {
	c := _m.On("GetName", matchers...)
	return &ExecutableWorkflow_GetName{Call: c}
}

// GetName provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetNamespace struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNamespace) Return(_a0 string) *ExecutableWorkflow_GetNamespace {
	return &ExecutableWorkflow_GetNamespace{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetNamespace() *ExecutableWorkflow_GetNamespace {
	c := _m.On("GetNamespace")
	return &ExecutableWorkflow_GetNamespace{Call: c}
}

func (_m *ExecutableWorkflow) OnGetNamespaceMatch(matchers ...interface{}) *ExecutableWorkflow_GetNamespace {
	c := _m.On("GetNamespace", matchers...)
	return &ExecutableWorkflow_GetNamespace{Call: c}
}

// GetNamespace provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetNamespace() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNode) Return(_a0 v1alpha1.ExecutableNode, _a1 bool) *ExecutableWorkflow_GetNode {
	return &ExecutableWorkflow_GetNode{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ExecutableWorkflow) OnGetNode(nodeID string) *ExecutableWorkflow_GetNode {
	c := _m.On("GetNode", nodeID)
	return &ExecutableWorkflow_GetNode{Call: c}
}

func (_m *ExecutableWorkflow) OnGetNodeMatch(matchers ...interface{}) *ExecutableWorkflow_GetNode {
	c := _m.On("GetNode", matchers...)
	return &ExecutableWorkflow_GetNode{Call: c}
}

// GetNode provides a mock function with given fields: nodeID
func (_m *ExecutableWorkflow) GetNode(nodeID string) (v1alpha1.ExecutableNode, bool) {
	ret := _m.Called(nodeID)

	var r0 v1alpha1.ExecutableNode
	if rf, ok := ret.Get(0).(func(string) v1alpha1.ExecutableNode); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNode)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(nodeID)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

type ExecutableWorkflow_GetNodeExecutionStatus struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNodeExecutionStatus) Return(_a0 v1alpha1.ExecutableNodeStatus) *ExecutableWorkflow_GetNodeExecutionStatus {
	return &ExecutableWorkflow_GetNodeExecutionStatus{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetNodeExecutionStatus(id string) *ExecutableWorkflow_GetNodeExecutionStatus {
	c := _m.On("GetNodeExecutionStatus", id)
	return &ExecutableWorkflow_GetNodeExecutionStatus{Call: c}
}

func (_m *ExecutableWorkflow) OnGetNodeExecutionStatusMatch(matchers ...interface{}) *ExecutableWorkflow_GetNodeExecutionStatus {
	c := _m.On("GetNodeExecutionStatus", matchers...)
	return &ExecutableWorkflow_GetNodeExecutionStatus{Call: c}
}

// GetNodeExecutionStatus provides a mock function with given fields: id
func (_m *ExecutableWorkflow) GetNodeExecutionStatus(id string) v1alpha1.ExecutableNodeStatus {
	ret := _m.Called(id)

	var r0 v1alpha1.ExecutableNodeStatus
	if rf, ok := ret.Get(0).(func(string) v1alpha1.ExecutableNodeStatus); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNodeStatus)
		}
	}

	return r0
}

type ExecutableWorkflow_GetNodes struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNodes) Return(_a0 []string) *ExecutableWorkflow_GetNodes {
	return &ExecutableWorkflow_GetNodes{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetNodes() *ExecutableWorkflow_GetNodes {
	c := _m.On("GetNodes")
	return &ExecutableWorkflow_GetNodes{Call: c}
}

func (_m *ExecutableWorkflow) OnGetNodesMatch(matchers ...interface{}) *ExecutableWorkflow_GetNodes {
	c := _m.On("GetNodes", matchers...)
	return &ExecutableWorkflow_GetNodes{Call: c}
}

// GetNodes provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetNodes() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOnFailureNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOnFailureNode) Return(_a0 v1alpha1.ExecutableNode) *ExecutableWorkflow_GetOnFailureNode {
	return &ExecutableWorkflow_GetOnFailureNode{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOnFailureNode() *ExecutableWorkflow_GetOnFailureNode {
	c := _m.On("GetOnFailureNode")
	return &ExecutableWorkflow_GetOnFailureNode{Call: c}
}

func (_m *ExecutableWorkflow) OnGetOnFailureNodeMatch(matchers ...interface{}) *ExecutableWorkflow_GetOnFailureNode {
	c := _m.On("GetOnFailureNode", matchers...)
	return &ExecutableWorkflow_GetOnFailureNode{Call: c}
}

// GetOnFailureNode provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOnFailureNode() v1alpha1.ExecutableNode {
	ret := _m.Called()

	var r0 v1alpha1.ExecutableNode
	if rf, ok := ret.Get(0).(func() v1alpha1.ExecutableNode); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNode)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOutputBindings struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOutputBindings) Return(_a0 []*v1alpha1.Binding) *ExecutableWorkflow_GetOutputBindings {
	return &ExecutableWorkflow_GetOutputBindings{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOutputBindings() *ExecutableWorkflow_GetOutputBindings {
	c := _m.On("GetOutputBindings")
	return &ExecutableWorkflow_GetOutputBindings{Call: c}
}

func (_m *ExecutableWorkflow) OnGetOutputBindingsMatch(matchers ...interface{}) *ExecutableWorkflow_GetOutputBindings {
	c := _m.On("GetOutputBindings", matchers...)
	return &ExecutableWorkflow_GetOutputBindings{Call: c}
}

// GetOutputBindings provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOutputBindings() []*v1alpha1.Binding {
	ret := _m.Called()

	var r0 []*v1alpha1.Binding
	if rf, ok := ret.Get(0).(func() []*v1alpha1.Binding); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Binding)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOutputs struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOutputs) Return(_a0 *v1alpha1.OutputVarMap) *ExecutableWorkflow_GetOutputs {
	return &ExecutableWorkflow_GetOutputs{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOutputs() *ExecutableWorkflow_GetOutputs {
	c := _m.On("GetOutputs")
	return &ExecutableWorkflow_GetOutputs{Call: c}
}

func (_m *ExecutableWorkflow) OnGetOutputsMatch(matchers ...interface{}) *ExecutableWorkflow_GetOutputs {
	c := _m.On("GetOutputs", matchers...)
	return &ExecutableWorkflow_GetOutputs{Call: c}
}

// GetOutputs provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOutputs() *v1alpha1.OutputVarMap {
	ret := _m.Called()

	var r0 *v1alpha1.OutputVarMap
	if rf, ok := ret.Get(0).(func() *v1alpha1.OutputVarMap); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.OutputVarMap)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOwnerReference struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOwnerReference) Return(_a0 v1.OwnerReference) *ExecutableWorkflow_GetOwnerReference {
	return &ExecutableWorkflow_GetOwnerReference{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOwnerReference() *ExecutableWorkflow_GetOwnerReference {
	c := _m.On("GetOwnerReference")
	return &ExecutableWorkflow_GetOwnerReference{Call: c}
}

func (_m *ExecutableWorkflow) OnGetOwnerReferenceMatch(matchers ...interface{}) *ExecutableWorkflow_GetOwnerReference {
	c := _m.On("GetOwnerReference", matchers...)
	return &ExecutableWorkflow_GetOwnerReference{Call: c}
}

// GetOwnerReference provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOwnerReference() v1.OwnerReference {
	ret := _m.Called()

	var r0 v1.OwnerReference
	if rf, ok := ret.Get(0).(func() v1.OwnerReference); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1.OwnerReference)
	}

	return r0
}

type ExecutableWorkflow_GetServiceAccountName struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetServiceAccountName) Return(_a0 string) *ExecutableWorkflow_GetServiceAccountName {
	return &ExecutableWorkflow_GetServiceAccountName{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetServiceAccountName() *ExecutableWorkflow_GetServiceAccountName {
	c := _m.On("GetServiceAccountName")
	return &ExecutableWorkflow_GetServiceAccountName{Call: c}
}

func (_m *ExecutableWorkflow) OnGetServiceAccountNameMatch(matchers ...interface{}) *ExecutableWorkflow_GetServiceAccountName {
	c := _m.On("GetServiceAccountName", matchers...)
	return &ExecutableWorkflow_GetServiceAccountName{Call: c}
}

// GetServiceAccountName provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetServiceAccountName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetTask struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetTask) Return(_a0 v1alpha1.ExecutableTask, _a1 error) *ExecutableWorkflow_GetTask {
	return &ExecutableWorkflow_GetTask{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ExecutableWorkflow) OnGetTask(id string) *ExecutableWorkflow_GetTask {
	c := _m.On("GetTask", id)
	return &ExecutableWorkflow_GetTask{Call: c}
}

func (_m *ExecutableWorkflow) OnGetTaskMatch(matchers ...interface{}) *ExecutableWorkflow_GetTask {
	c := _m.On("GetTask", matchers...)
	return &ExecutableWorkflow_GetTask{Call: c}
}

// GetTask provides a mock function with given fields: id
func (_m *ExecutableWorkflow) GetTask(id string) (v1alpha1.ExecutableTask, error) {
	ret := _m.Called(id)

	var r0 v1alpha1.ExecutableTask
	if rf, ok := ret.Get(0).(func(string) v1alpha1.ExecutableTask); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableTask)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ExecutableWorkflow_StartNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_StartNode) Return(_a0 v1alpha1.ExecutableNode) *ExecutableWorkflow_StartNode {
	return &ExecutableWorkflow_StartNode{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnStartNode() *ExecutableWorkflow_StartNode {
	c := _m.On("StartNode")
	return &ExecutableWorkflow_StartNode{Call: c}
}

func (_m *ExecutableWorkflow) OnStartNodeMatch(matchers ...interface{}) *ExecutableWorkflow_StartNode {
	c := _m.On("StartNode", matchers...)
	return &ExecutableWorkflow_StartNode{Call: c}
}

// StartNode provides a mock function with given fields:
func (_m *ExecutableWorkflow) StartNode() v1alpha1.ExecutableNode {
	ret := _m.Called()

	var r0 v1alpha1.ExecutableNode
	if rf, ok := ret.Get(0).(func() v1alpha1.ExecutableNode); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNode)
		}
	}

	return r0
}
