package v1alpha1

import (
	"bytes"
	"context"
	"encoding/json"

	"github.com/lyft/flytestdlib/storage"

	"k8s.io/apimachinery/pkg/types"

	"github.com/golang/protobuf/jsonpb"
	"github.com/lyft/flyteidl/gen/pb-go/flyteidl/core"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const StartNodeID = "start-node"
const EndNodeID = "end-node"

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// FlyteWorkflow: represents one Execution Workflow object
type FlyteWorkflow struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	*WorkflowSpec     `json:"spec"`
	Inputs            *Inputs                      `json:"inputs,omitempty"`
	ExecutionID       ExecutionID                  `json:"executionId"`
	Tasks             map[TaskID]*TaskSpec         `json:"tasks"`
	SubWorkflows      map[WorkflowID]*WorkflowSpec `json:"subWorkflows,omitempty"`
	// StartTime before the system will actively try to mark it failed and kill associated containers.
	// Value must be a positive integer.
	// +optional
	ActiveDeadlineSeconds *int64 `json:"activeDeadlineSeconds,omitempty"`
	// Defaults value of parameters to be used for nodes if not set by the node.
	NodeDefaults NodeDefaults `json:"node-defaults,omitempty"`
	// Specifies the time when the workflow has been accepted into the system.
	AcceptedAt *metav1.Time `json:"acceptedAt,omitempty"`
	// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	// +optional
	ServiceAccountName string `json:"serviceAccountName,omitempty" protobuf:"bytes,8,opt,name=serviceAccountName"`
	// Status is the only mutable section in the workflow. It holds all the execution information
	Status WorkflowStatus `json:"status,omitempty"`

	// non-Serialized fields
	DataReferenceConstructor storage.ReferenceConstructor `json:"-"`

	// Description
	// +optional
	QueuingBudgetSeconds *int64
}

type NodeDefaults struct {
	// Default behaviour for Interruptible for nodes unless explicitly set at the node level.
	Interruptible bool `json:"interruptible,omitempty"`
}

var FlyteWorkflowGVK = SchemeGroupVersion.WithKind(FlyteWorkflowKind)

func (in *FlyteWorkflow) GetOwnerReference() metav1.OwnerReference {
	// TODO Open Issue - https://github.com/kubernetes/client-go/issues/308
	// For some reason the CRD does not have the GVK correctly populated. So we will fake it.
	if len(in.GroupVersionKind().Group) == 0 || len(in.GroupVersionKind().Kind) == 0 || len(in.GroupVersionKind().Version) == 0 {
		return *metav1.NewControllerRef(in, FlyteWorkflowGVK)
	}
	return *metav1.NewControllerRef(in, in.GroupVersionKind())
}

func (in *FlyteWorkflow) GetTask(id TaskID) (ExecutableTask, error) {
	t, ok := in.Tasks[id]
	if !ok {
		return nil, errors.Errorf("Unable to find task with Id [%v]", id)
	}
	return t, nil
}

func (in *FlyteWorkflow) GetExecutionStatus() ExecutableWorkflowStatus {
	s := &in.Status
	s.DataReferenceConstructor = in.DataReferenceConstructor
	return s
}

func (in *FlyteWorkflow) GetK8sWorkflowID() types.NamespacedName {
	return types.NamespacedName{
		Name:      in.GetName(),
		Namespace: in.GetNamespace(),
	}
}

func (in *FlyteWorkflow) GetExecutionID() ExecutionID {
	return in.ExecutionID
}

func (in *FlyteWorkflow) FindSubWorkflow(subID WorkflowID) ExecutableSubWorkflow {
	s, ok := in.SubWorkflows[subID]
	if !ok {
		return nil
	}
	return s
}

func (in *FlyteWorkflow) GetNodeExecutionStatus(ctx context.Context, id NodeID) ExecutableNodeStatus {
	return in.GetExecutionStatus().GetNodeExecutionStatus(ctx, id)
}

func (in *FlyteWorkflow) GetServiceAccountName() string {
	return in.ServiceAccountName
}

func (in *FlyteWorkflow) IsInterruptible() bool {
	return in.NodeDefaults.Interruptible
}

type Inputs struct {
	*core.LiteralMap
}

func (in *Inputs) UnmarshalJSON(b []byte) error {
	in.LiteralMap = &core.LiteralMap{}
	return jsonpb.Unmarshal(bytes.NewReader(b), in.LiteralMap)
}

func (in *Inputs) MarshalJSON() ([]byte, error) {
	if in == nil {
		return []byte{}, nil
	}
	var buf bytes.Buffer
	if err := marshaler.Marshal(&buf, in.LiteralMap); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Inputs) DeepCopyInto(out *Inputs) {
	*out = *in
	// We do not manipulate the object, so its ok
	// Once we figure out the autogenerate story we can replace this
}

type Connections struct {
	DownstreamEdges map[NodeID][]NodeID
	UpstreamEdges   map[NodeID][]NodeID
}

func (in *Connections) UnmarshalJSON(b []byte) error {
	in.DownstreamEdges = map[NodeID][]NodeID{}
	err := json.Unmarshal(b, &in.DownstreamEdges)
	if err != nil {
		return err
	}
	in.UpstreamEdges = map[NodeID][]NodeID{}
	for from, nodes := range in.DownstreamEdges {
		for _, to := range nodes {
			if _, ok := in.UpstreamEdges[to]; !ok {
				in.UpstreamEdges[to] = []NodeID{}
			}
			in.UpstreamEdges[to] = append(in.UpstreamEdges[to], from)
		}
	}
	return nil
}

func (in *Connections) MarshalJSON() ([]byte, error) {
	return json.Marshal(in.DownstreamEdges)
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Connections) DeepCopyInto(out *Connections) {
	*out = *in
	// We do not manipulate the object, so its ok
	// Once we figure out the autogenerate story we can replace this
}

// WorkflowSpec is the spec for the actual Flyte Workflow (DAG)
type WorkflowSpec struct {
	ID    WorkflowID           `json:"id"`
	Nodes map[NodeID]*NodeSpec `json:"nodes"`

	// Defines the set of connections (both data dependencies and execution dependencies) that the graph is
	// formed of. The execution engine will respect and follow these connections as it determines which nodes
	// can and should be executed.
	Connections Connections `json:"connections"`

	// Defines a single node to execute in case the system determined the Workflow has failed.
	OnFailure *NodeSpec `json:"onFailure,omitempty"`

	// Defines the declaration of the outputs types and names this workflow is expected to generate.
	Outputs *OutputVarMap `json:"outputs,omitempty"`

	// Defines the data links used to construct the final outputs of the workflow. Bindings will typically
	// refer to specific outputs of a subset of the nodes executed in the Workflow. When executing the end-node,
	// the execution engine will traverse these bindings and assemble the final set of outputs of the workflow.
	OutputBindings []*Binding `json:"outputBindings,omitempty"`
}

func (in *WorkflowSpec) StartNode() ExecutableNode {
	n, ok := in.Nodes[StartNodeID]
	if !ok {
		return nil
	}
	return n
}

func (in *WorkflowSpec) GetID() WorkflowID {
	return in.ID
}

func (in *WorkflowSpec) ToNode(name NodeID) ([]NodeID, error) {
	if _, ok := in.Nodes[name]; !ok {
		return nil, errors.Errorf("Bad Node [%v], is not defined in the Workflow [%v]", name, in.ID)
	}
	upstreamNodes := in.Connections.UpstreamEdges[name]
	return upstreamNodes, nil
}

func (in *WorkflowSpec) FromNode(name NodeID) ([]NodeID, error) {
	if _, ok := in.Nodes[name]; !ok {
		return nil, errors.Errorf("Bad Node [%v], is not defined in the Workflow [%v]", name, in.ID)
	}

	downstreamNodes := in.Connections.DownstreamEdges[name]
	return downstreamNodes, nil
}

func (in *WorkflowSpec) GetOutputs() *OutputVarMap {
	return in.Outputs
}

func (in *WorkflowSpec) GetNode(nodeID NodeID) (ExecutableNode, bool) {
	n, ok := in.Nodes[nodeID]
	return n, ok
}

func (in *WorkflowSpec) GetConnections() *Connections {
	return &in.Connections
}

func (in *WorkflowSpec) GetOutputBindings() []*Binding {
	return in.OutputBindings
}

func (in *WorkflowSpec) GetOnFailureNode() ExecutableNode {
	if in.OnFailure == nil {
		return nil
	}
	return in.OnFailure
}

func (in *WorkflowSpec) GetNodes() []NodeID {
	nodeIds := make([]NodeID, 0, len(in.Nodes))
	for id := range in.Nodes {
		nodeIds = append(nodeIds, id)
	}
	return nodeIds
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// FlyteWorkflowList is a list of FlyteWorkflow resources
type FlyteWorkflowList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata"`
	Items           []FlyteWorkflow `json:"items"`
}
