package v1alpha1

import (
	"bytes"

	"github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core"
	"github.com/golang/protobuf/jsonpb"
)

type Error struct {
	*core.Error `json:",inline"`
}

func (in Error) UnmarshalJSON(b []byte) error {
	in.Error = &core.Error{}
	return jsonpb.Unmarshal(bytes.NewReader(b), in.Error)
}

func (in Error) MarshalJSON() ([]byte, error) {
	if in.Error == nil {
		return nilJSON, nil
	}

	var buf bytes.Buffer
	if err := marshaler.Marshal(&buf, in.Error); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Error) DeepCopyInto(out *Error) {
	*out = *in
	// We do not manipulate the object, so its ok
	// Once we figure out the autogenerate story we can replace this

}

type BooleanExpression struct {
	*core.BooleanExpression `json:"-"`
}

func (in BooleanExpression) MarshalJSON() ([]byte, error) {
	if in.BooleanExpression == nil {
		return nilJSON, nil
	}

	var buf bytes.Buffer
	if err := marshaler.Marshal(&buf, in.BooleanExpression); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (in *BooleanExpression) UnmarshalJSON(b []byte) error {
	in.BooleanExpression = &core.BooleanExpression{}
	return jsonpb.Unmarshal(bytes.NewReader(b), in.BooleanExpression)
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BooleanExpression) DeepCopyInto(out *BooleanExpression) {
	*out = *in
	// We do not manipulate the object, so its ok
	// Once we figure out the autogenerate story we can replace this
}

type IfBlock struct {
	Condition BooleanExpression `json:"condition"`
	ThenNode  *NodeID           `json:"then"`
}

func (in IfBlock) GetCondition() *core.BooleanExpression {
	return in.Condition.BooleanExpression
}

func (in *IfBlock) GetThenNode() *NodeID {
	return in.ThenNode
}

type BranchNodeSpec struct {
	If       IfBlock    `json:"if"`
	// +listType=atomic
	ElseIf   []*IfBlock `json:"elseIf,omitempty"`
	Else     *NodeID    `json:"else,omitempty"`
	ElseFail *Error     `json:"elseFail,omitempty"`
}

func (in *BranchNodeSpec) GetIf() ExecutableIfBlock {
	return &in.If
}

func (in *BranchNodeSpec) GetElse() *NodeID {
	return in.Else
}

func (in *BranchNodeSpec) GetElseIf() []ExecutableIfBlock {
	elifs := make([]ExecutableIfBlock, 0, len(in.ElseIf))
	for _, b := range in.ElseIf {
		elifs = append(elifs, b)
	}
	return elifs
}

func (in *BranchNodeSpec) GetElseFail() *core.Error {
	if in.ElseFail != nil {
		return in.ElseFail.Error
	}
	return nil
}
