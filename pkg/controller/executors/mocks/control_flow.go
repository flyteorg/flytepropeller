// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// ControlFlow is an autogenerated mock type for the ControlFlow type
type ControlFlow struct {
	mock.Mock
}

type ControlFlow_CurrentParallelism struct {
	*mock.Call
}

func (_m ControlFlow_CurrentParallelism) Return(_a0 uint32) *ControlFlow_CurrentParallelism {
	return &ControlFlow_CurrentParallelism{Call: _m.Call.Return(_a0)}
}

func (_m *ControlFlow) OnCurrentParallelism() *ControlFlow_CurrentParallelism {
	c_call := _m.On("CurrentParallelism")
	return &ControlFlow_CurrentParallelism{Call: c_call}
}

func (_m *ControlFlow) OnCurrentParallelismMatch(matchers ...interface{}) *ControlFlow_CurrentParallelism {
	c_call := _m.On("CurrentParallelism", matchers...)
	return &ControlFlow_CurrentParallelism{Call: c_call}
}

// CurrentParallelism provides a mock function with given fields:
func (_m *ControlFlow) CurrentParallelism() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

type ControlFlow_IncrementParallelism struct {
	*mock.Call
}

func (_m ControlFlow_IncrementParallelism) Return(_a0 uint32) *ControlFlow_IncrementParallelism {
	return &ControlFlow_IncrementParallelism{Call: _m.Call.Return(_a0)}
}

func (_m *ControlFlow) OnIncrementParallelism() *ControlFlow_IncrementParallelism {
	c_call := _m.On("IncrementParallelism")
	return &ControlFlow_IncrementParallelism{Call: c_call}
}

func (_m *ControlFlow) OnIncrementParallelismMatch(matchers ...interface{}) *ControlFlow_IncrementParallelism {
	c_call := _m.On("IncrementParallelism", matchers...)
	return &ControlFlow_IncrementParallelism{Call: c_call}
}

// IncrementParallelism provides a mock function with given fields:
func (_m *ControlFlow) IncrementParallelism() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}
